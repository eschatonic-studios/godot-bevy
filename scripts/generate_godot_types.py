#!/usr/bin/env python3
"""
Fully automatic Godot type generation for godot-bevy.

This script:
1. Runs `godot --dump-extension-api` to generate extension_api.json
2. Parses all Node-derived types from the API
3. Generates comprehensive node marker components
4. Generates complete type checking functions
5. Updates the scene tree plugin to use generated code

Usage: python scripts/generate_godot_types.py
"""

import json
import os
import subprocess
import sys
from pathlib import Path
from collections import defaultdict

class GodotTypeGenerator:
    def __init__(self):
        self.project_root = Path(__file__).parent.parent
        self.api_file = self.project_root / "extension_api.json"
        self.node_markers_file = self.project_root / "godot-bevy" / "src" / "interop" / "node_markers.rs"
        self.type_checking_file = self.project_root / "godot-bevy" / "src" / "plugins" / "scene_tree" / "node_type_checking_generated.rs"
        self.plugin_file = self.project_root / "godot-bevy" / "src" / "plugins" / "scene_tree" / "plugin.rs"

    def run_godot_dump_api(self):
        """Run godot --dump-extension-api to generate extension_api.json"""
        print("üöÄ Generating extension_api.json from Godot...")

        try:
            # Try different common Godot executable names
            godot_commands = ["godot", "godot4", "/usr/local/bin/godot"]

            for cmd in godot_commands:
                try:
                    result = subprocess.run([
                        cmd, "--headless", "--dump-extension-api", str(self.api_file)
                    ], capture_output=True, text=True, timeout=30)

                    if result.returncode == 0 and self.api_file.exists():
                        print(f"‚úÖ Successfully generated extension_api.json using '{cmd}'")
                        return

                except (subprocess.TimeoutExpired, FileNotFoundError):
                    continue

            # If all commands failed, give helpful error
            raise RuntimeError(
                "Could not run Godot to generate extension_api.json.\n"
                "Please ensure Godot 4 is installed and available in PATH.\n"
                "You can also manually run: godot --dump-extension-api extension_api.json"
            )

        except Exception as e:
            print(f"‚ùå Error generating extension_api.json: {e}")
            sys.exit(1)

    def load_and_parse_extension_api(self):
        """Load and parse the extension API to extract node types"""
        print("üìñ Parsing extension API...")

        if not self.api_file.exists():
            raise FileNotFoundError(f"extension_api.json not found at {self.api_file}")

        with open(self.api_file) as f:
            api = json.load(f)

        # Build inheritance relationships
        inheritance_map = defaultdict(list)
        parent_map = {}

        for class_info in api["classes"]:
            name = class_info["name"]
            if "inherits" in class_info:
                parent = class_info["inherits"]
                inheritance_map[parent].append(name)
                parent_map[name] = parent

        # Collect all Node-derived types
        node_types = set()

        def collect_descendants(class_name):
            node_types.add(class_name)
            for child in inheritance_map.get(class_name, []):
                collect_descendants(child)

        collect_descendants("Node")

        # Filter out base Node class and editor-only classes
        excluded_prefixes = ["Editor", "ScriptEditor", "VisualShader"]
        excluded_types = {"Node", "MissingNode", "ImporterMeshInstance3D"}

        filtered_types = sorted([
            t for t in node_types
            if not any(t.startswith(prefix) for prefix in excluded_prefixes)
            and t not in excluded_types
        ])

        print(f"‚úÖ Found {len(filtered_types)} node types")
        return filtered_types, parent_map

    def generate_node_markers(self, node_types):
        """Generate the node_markers.rs file"""
        print("üè∑Ô∏è  Generating node markers...")

        content = '''use bevy::ecs::component::Component;

/// Marker components for Godot node types.
/// These enable type-safe ECS queries like: Query<&GodotNodeHandle, With<Sprite2DMarker>>
///
/// ü§ñ This file is automatically generated by scripts/generate_godot_types.py
/// To regenerate: python scripts/generate_godot_types.py

// Base node type marker
#[derive(Component, Debug, Clone, Copy, PartialEq, Eq)]
pub struct NodeMarker;

'''

        # Generate all markers
        for node_type in node_types:
            content += f"#[derive(Component, Debug, Clone, Copy, PartialEq, Eq)]\n"
            content += f"pub struct {node_type}Marker;\n\n"

        with open(self.node_markers_file, "w") as f:
            f.write(content)

        print(f"‚úÖ Generated {len(node_types)} node markers")

    def categorize_types_by_hierarchy(self, node_types, parent_map):
        """Categorize node types by their inheritance hierarchy"""

        def is_descendant_of(node_type, ancestor):
            current = node_type
            while current in parent_map:
                current = parent_map[current]
                if current == ancestor:
                    return True
            return False

        categories = {
            "3d": [],
            "2d": [],
            "control": [],
            "universal": []
        }

        for node_type in node_types:
            if is_descendant_of(node_type, "Node3D"):
                categories["3d"].append(node_type)
            elif is_descendant_of(node_type, "Node2D"):
                categories["2d"].append(node_type)
            elif is_descendant_of(node_type, "Control"):
                categories["control"].append(node_type)
            elif parent_map.get(node_type) == "Node":
                categories["universal"].append(node_type)

        return categories

    def generate_type_checking_code(self, node_types, parent_map):
        """Generate the complete type checking implementation"""
        print("üîç Generating type checking code...")

        # Filter out invalid Godot classes first to avoid unnecessary work
        valid_types = self.filter_valid_godot_classes(node_types)

        # Categorize only the valid types
        categories = self.categorize_types_by_hierarchy(valid_types, parent_map)

        content = f'''// ü§ñ This file is automatically generated by scripts/generate_godot_types.py
// To regenerate: python scripts/generate_godot_types.py

use bevy::ecs::system::EntityCommands;
use crate::interop::{{GodotNodeHandle, node_markers::*}};

/// Adds appropriate marker components to an entity based on the Godot node type.
/// This function is automatically generated and handles all {len(valid_types)} Godot node types.
///
/// Godot's hierarchy: Node -> {{Node3D, CanvasItem -> {{Node2D, Control}}, Others}}
/// We check the major branches: 3D, 2D, Control (UI), and Universal (direct Node children)
pub fn add_comprehensive_node_type_markers(
    entity_commands: &mut EntityCommands,
    node: &mut GodotNodeHandle,
) {{
    // All nodes inherit from Node, so add this first
    entity_commands.insert(NodeMarker);

    // Check the major hierarchy branches to minimize FFI calls
    if node.try_get::<godot::classes::Node3D>().is_some() {{
        entity_commands.insert(Node3DMarker);
        check_3d_node_types_comprehensive(entity_commands, node);
    }} else if node.try_get::<godot::classes::Node2D>().is_some() {{
        entity_commands.insert(Node2DMarker);
        entity_commands.insert(CanvasItemMarker); // Node2D inherits from CanvasItem
        check_2d_node_types_comprehensive(entity_commands, node);
    }} else if node.try_get::<godot::classes::Control>().is_some() {{
        entity_commands.insert(ControlMarker);
        entity_commands.insert(CanvasItemMarker); // Control inherits from CanvasItem
        check_control_node_types_comprehensive(entity_commands, node);
    }}

    // Check node types that inherit directly from Node
    check_universal_node_types_comprehensive(entity_commands, node);
}}

pub fn remove_comprehensive_node_type_markers(
    entity_commands: &mut EntityCommands,
    node: &mut GodotNodeHandle,
) {{
    // All nodes inherit from Node, so remove this first
    entity_commands.remove::<NodeMarker>();

    // Check the major hierarchy branches to minimize FFI calls
    if node.try_get::<godot::classes::Node3D>().is_some() {{
        entity_commands.remove::<Node3DMarker>();
        remove_3d_node_types_comprehensive(entity_commands, node);
    }} else if node.try_get::<godot::classes::Node2D>().is_some() {{
        entity_commands.remove::<Node2DMarker>();
        entity_commands.remove::<CanvasItemMarker>(); // Node2D inherits from CanvasItem
        remove_2d_node_types_comprehensive(entity_commands, node);
    }} else if node.try_get::<godot::classes::Control>().is_some() {{
        entity_commands.remove::<ControlMarker>();
        entity_commands.remove::<CanvasItemMarker>(); // Control inherits from CanvasItem
        remove_control_node_types_comprehensive(entity_commands, node);
    }}

    // Check node types that inherit directly from Node
    remove_universal_node_types_comprehensive(entity_commands, node);
}}

'''

        # Generate specific checking functions
        content += self._generate_hierarchy_function_comprehensive("3d", categories["3d"])
        content += self._generate_hierarchy_function_comprehensive("2d", categories["2d"])
        content += self._generate_hierarchy_function_comprehensive("control", categories["control"])
        content += self._generate_universal_function_comprehensive(categories["universal"])

        with open(self.type_checking_file, "w") as f:
            f.write(content)

        print(f"‚úÖ Generated type checking for {len(valid_types)} types")

    def filter_valid_godot_classes(self, node_types):
        """Filter out Godot classes that don't exist or aren't available"""
        # Known classes that don't exist in current Godot version or aren't available
        excluded_classes = {
            # CSG classes (require special module)
            'CSGBox3D', 'CSGCombiner3D', 'CSGCylinder3D', 'CSGMesh3D', 'CSGPolygon3D',
            'CSGPrimitive3D', 'CSGShape3D', 'CSGSphere3D', 'CSGTorus3D',
            # Editor classes
            'GridMapEditorPlugin', 'ScriptCreateDialog', 'FileSystemDock',
            'OpenXRBindingModifierEditor', 'OpenXRInteractionProfileEditor',
            'OpenXRInteractionProfileEditorBase',
            # XR classes that might not be available
            'XRAnchor3D', 'XRBodyModifier3D', 'XRCamera3D', 'XRController3D',
            'XRFaceModifier3D', 'XRHandModifier3D', 'XRNode3D', 'XROrigin3D',
            # OpenXR classes
            'OpenXRCompositionLayer', 'OpenXRCompositionLayerCylinder',
            'OpenXRCompositionLayerEquirect', 'OpenXRCompositionLayerQuad',
            'OpenXRHand', 'OpenXRVisibilityMask',
            # Classes that might not be available in all builds
            'VoxelGI', 'LightmapGI', 'FogVolume', 'WorldEnvironment',
            # Navigation classes (might be module-specific)
            'NavigationAgent2D', 'NavigationAgent3D', 'NavigationLink2D',
            'NavigationLink3D', 'NavigationObstacle2D', 'NavigationObstacle3D',
            'NavigationRegion2D', 'NavigationRegion3D',
            # Other problematic classes
            'StatusIndicator',
            # Graph classes (not available in all Godot builds)
            'GraphEdit', 'GraphElement', 'GraphFrame', 'GraphNode',
            # Parallax2D is in extension API but not in current Rust bindings
            'Parallax2D',
        }

        return [t for t in node_types if t not in excluded_classes]

    def fix_godot_class_name_for_rust(self, class_name):
        """Fix Godot class names to match the actual Rust bindings"""
        # Map class names from extension API to actual Rust struct names
        name_fixes = {
            'CPUParticles2D': 'CpuParticles2D',
            'CPUParticles3D': 'CpuParticles3D',
            'GPUParticles2D': 'GpuParticles2D',
            'GPUParticles3D': 'GpuParticles3D',
            'GPUParticlesAttractor3D': 'GpuParticlesAttractor3D',
            'GPUParticlesAttractorBox3D': 'GpuParticlesAttractorBox3D',
            'GPUParticlesAttractorSphere3D': 'GpuParticlesAttractorSphere3D',
            'GPUParticlesAttractorVectorField3D': 'GpuParticlesAttractorVectorField3D',
            'GPUParticlesCollision3D': 'GpuParticlesCollision3D',
            'GPUParticlesCollisionBox3D': 'GpuParticlesCollisionBox3D',
            'GPUParticlesCollisionHeightField3D': 'GpuParticlesCollisionHeightField3D',
            'GPUParticlesCollisionSDF3D': 'GpuParticlesCollisionSdf3d',
            'GPUParticlesCollisionSphere3D': 'GpuParticlesCollisionSphere3D',
            'HTTPRequest': 'HttpRequest',
            'SkeletonIK3D': 'SkeletonIk3d',
            'Generic6DOFJoint3D': 'Generic6DofJoint3D',
        }

        return name_fixes.get(class_name, class_name)

    def _generate_hierarchy_function_comprehensive(self, name, types):
        """Generate a hierarchy-specific type checking function"""
        content = f'''fn check_{name}_node_types_comprehensive(
    entity_commands: &mut EntityCommands,
    node: &mut GodotNodeHandle,
) {{
'''

        for node_type in sorted(types):
            rust_class_name = self.fix_godot_class_name_for_rust(node_type)
            content += f'''    if node.try_get::<godot::classes::{rust_class_name}>().is_some() {{
        entity_commands.insert({node_type}Marker);
    }}
'''

        content += "}\n\n"

        content += f'''fn remove_{name}_node_types_comprehensive(
    entity_commands: &mut EntityCommands,
    node: &mut GodotNodeHandle,
) {{
    entity_commands

'''

        for node_type in sorted(types):
            rust_class_name = self.fix_godot_class_name_for_rust(node_type)
            content += f'''        .remove::<{node_type}Marker>()
'''

        content += ";}\n\n"
        return content

    def _generate_universal_function_comprehensive(self, types):
        """Generate the universal types checking function"""
        content = '''fn check_universal_node_types_comprehensive(
    entity_commands: &mut EntityCommands,
    node: &mut GodotNodeHandle,
) {
'''

        for node_type in sorted(types):
            rust_class_name = self.fix_godot_class_name_for_rust(node_type)
            content += f'''    if node.try_get::<godot::classes::{rust_class_name}>().is_some() {{
        entity_commands.insert({node_type}Marker);
    }}
'''

        content += "}\n"

        content += '''fn remove_universal_node_types_comprehensive(
    entity_commands: &mut EntityCommands,
    node: &mut GodotNodeHandle,
) {
    entity_commands

'''

        for node_type in sorted(types):
            rust_class_name = self.fix_godot_class_name_for_rust(node_type)
            content += f'''        .remove::<{node_type}Marker>()
'''

        content += ";}\n"
        return content

    def verify_plugin_integration(self):
        """Verify that the plugin is set up to use the generated code"""
        print("üîç Verifying plugin integration...")

        with open(self.plugin_file, "r") as f:
            content = f.read()

        if "add_comprehensive_node_type_markers" in content:
            print("‚úÖ Plugin is correctly integrated with generated code")
        else:
            print("‚ö†Ô∏è  Plugin integration needed:")
            print("   1. Add: use super::node_type_checking_generated::add_comprehensive_node_type_markers;")
            print("   2. Replace add_node_type_markers calls with add_comprehensive_node_type_markers")
            print("   3. This is a one-time setup - future script runs won't need this")

    def run(self):
        """Run the complete generation pipeline"""
        print("üéØ Starting Godot type generation pipeline...")

        try:
            # Step 1: Generate extension API
            self.run_godot_dump_api()

            # Step 2: Parse API and extract types
            node_types, parent_map = self.load_and_parse_extension_api()

            # Step 3: Generate node markers
            self.generate_node_markers(node_types)

            # Step 4: Generate type checking code
            self.generate_type_checking_code(node_types, parent_map)

            # Step 5: Verify plugin integration
            self.verify_plugin_integration()

            print(f"""
üéâ Generation complete!

Generated:
  ‚Ä¢ {len(node_types)} node marker components
  ‚Ä¢ Complete type checking functions

Files generated:
  ‚Ä¢ {self.node_markers_file.relative_to(self.project_root)}
  ‚Ä¢ {self.type_checking_file.relative_to(self.project_root)}

Next steps:
  ‚Ä¢ Run 'cargo check' to verify the build
  ‚Ä¢ Commit the generated files
""")

        except Exception as e:
            print(f"‚ùå Generation failed: {e}")
            sys.exit(1)

def main():
    generator = GodotTypeGenerator()
    generator.run()

if __name__ == "__main__":
    main()
